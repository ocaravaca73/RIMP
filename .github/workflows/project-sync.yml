name: Sync labels → Project fields

on:
  workflow_dispatch:
  issues:
    types: [opened, edited, labeled, unlabeled]
  pull_request:
    types: [opened, edited, labeled, unlabeled]

jobs:
  sync:
    runs-on: ubuntu-latest
    environment: copilot
    env:
      PROJECT_OWNER: ${{ github.repository_owner }}
      PROJECT_TITLE: 'RIMP – Product & Delivery'
    steps:
      - name: Sync labels to ProjectV2 fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.COPILOT_MCP_GITHUB_PROJECT_TOKEN }}
          script: |
            const owner = process.env.PROJECT_OWNER;
            const projectTitle = process.env.PROJECT_TITLE;
            const repo = context.repo.repo;
            const issue = context.payload.issue;
            const pr = context.payload.pull_request;
            const content = issue ?? pr;
            if (!content) { core.info('No issue/PR in event; exit.'); return; }
            const contentId = content.node_id;

            let labels = (content.labels || []).map(l => typeof l === 'string' ? l : l.name);
            if (!labels.length) {
              const { data } = await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: content.number
              });
              labels = data.map(l => l.name);
            }
            labels = labels.map(s => s.trim().toLowerCase());

            const qProject = `
              query($owner:String!, $title:String!) {
                user(login: $owner) {
                  projectsV2(first: 50, query: $title) {
                    nodes {
                      id
                      title
                      fields(first: 100) {
                        nodes {
                          __typename
                          id
                          name
                          ... on ProjectV2SingleSelectField {
                            options { id name }
                          }
                          ... on ProjectV2IterationField {
                            configuration { iterations { id title } }
                          }
                        }
                      }
                    }
                  }
                }
              }`;
            const prjRes = await github.graphql(qProject, { owner, title: projectTitle });
            const project = prjRes.user?.projectsV2?.nodes?.find(p => p.title === projectTitle);
            if (!project) { core.setFailed(`Project "${projectTitle}" not found.`); return; }

            const fields = project.fields.nodes;
            const findField = name => fields.find(f => f.name === name);
            const getSelectId = (field, name) => field?.options?.find(o => o.name === name)?.id;

            const itemId = await (async () => {
              const qFindItem = `
                query($contentId: ID!) {
                  node(id: $contentId) {
                    ... on Issue { projectItems(first: 50) { nodes { id project { id } } } }
                    ... on PullRequest { projectItems(first: 50) { nodes { id project { id } } } }
                  }
                }`;
              const res = await github.graphql(qFindItem, { contentId });
              const items = res.node?.projectItems?.nodes || [];
              const existing = items.find(n => n.project?.id === project.id);
              if (existing) return existing.id;

              const addItem = `
                mutation($projectId:ID!, $contentId:ID!) {
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                    item { id }
                  }
                }`;
              const addRes = await github.graphql(addItem, { projectId: project.id, contentId });
              return addRes.addProjectV2ItemById.item.id;
            })();

            if (!itemId) return;

            const updateField = async (field, value, type) => {
              if (!field || value == null) return;
              const mutation = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $value: ${type}) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ ${type === 'Date!' ? 'date' : type === 'Float!' ? 'number' : type === 'String!' ? 'text' : 'singleSelectOptionId'}: $value }
                  }) { projectV2Item { id } }
                }`;
              await github.graphql(mutation, {
                projectId: project.id,
                itemId,
                fieldId: field.id,
                value: value
              });
            };

            const mappings = {
              'Status': {
                map: {
                  'status:backlog': 'Backlog',
                  'status:ready': 'Ready',
                  'status:in-progress': 'In Progress',
                  'status:blocked': 'Blocked',
                  'status:in-review': 'In Review',
                  'status:done': 'Done'
                },
                type: 'select'
              },
              'Type': {
                map: {
                  'type:feature': 'Feature',
                  'type:spike': 'Spike',
                  'type:task': 'Task',
                  'type:bug': 'Bug',
                  'type:chore': 'Chore'
                },
                type: 'select'
              },
              'Priority': {
                map: {
                  'prio:p0': 'P0',
                  'prio:p1': 'P1',
                  'prio:p2': 'P2',
                  'prio:p3': 'P3'
                },
                type: 'select'
              },
              'Area': {
                map: {
                  'area:app': 'App',
                  'area:backend': 'Backend',
                  'area:realtime': 'Realtime',
                  'area:telemetry': 'Telemetry',
                  'area:data': 'Data',
                  'area:ux': 'UX',
                  'area:ops': 'Ops'
                },
                type: 'select'
              }
            };

            for (const [fieldName, { map, type }] of Object.entries(mappings)) {
              const field = findField(fieldName);
              for (const [label, value] of Object.entries(map)) {
                if (labels.includes(label)) {
                  const optionId = getSelectId(field, value);
                  if (optionId) await updateField(field, optionId, 'String!');
                  break;
                }
              }
            }

            const numericFields = ['Estimate (pts)', 'Reach', 'Impact', 'Confidence', 'Effort', 'RICE'];
            for (const name of numericFields) {
              const field = findField(name);
              const label = labels.find(l => l.startsWith(name.toLowerCase().replace(/[^a-z]/g, '') + ':'));
              if (field && label) {
                const val = parseFloat(label.split(':')[1]);
                if (!isNaN(val)) await updateField(field, val, 'Float!');
              }
            }

            const textField = findField('Target Release');
            const releaseLabel = labels.find(l => l.startsWith('release:'));
            if (textField && releaseLabel) {
              await updateField(textField, releaseLabel.split(':')[1], 'String!');
            }

            const dateFields = ['Started At', 'Finished At'];
            for (const name of dateFields) {
              const field = findField(name);
              const label = labels.find(l => l.startsWith(name.toLowerCase().replace(/[^a-z]/g, '') + ':'));
              if (field && label) {
                await updateField(field, label.split(':')[1], 'Date!');
              }
            }

            const sprintField = fields.find(f => f.__typename === 'ProjectV2IterationField' && f.name === 'Sprint (2w)');
            const currentIteration = sprintField?.configuration?.iterations?.find(i => i.title === 'Current');
            if (sprintField && currentIteration) {
              await updateField(sprintField, currentIteration.id, 'String!');
            }

            core.info('✓ Project fields updated successfully.');
