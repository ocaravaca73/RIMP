name: Sync labels with Project fields

on:
  workflow_dispatch:
  issues:
    types: [opened, edited, labeled, unlabeled]
  pull_request:
    types: [opened, edited, labeled, unlabeled]

jobs:
  sync:
    runs-on: ubuntu-latest
    environment: copilot   # usa los secretos del entorno 'copilot'
    env:
      PROJECT_OWNER: ${{ github.repository_owner }}
      PROJECT_TITLE: RIMP – Product & Delivery
    steps:
      - name: Map labels → Project fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.COPILOT_MCP_GITHUB_PROJECT_TOKEN }}  # PAT classic con scope 'project'
          script: |
            const owner = process.env.PROJECT_OWNER;
            const projectTitle = process.env.PROJECT_TITLE;

            // 1) Tomar issue/PR y labels
            const content = context.payload.issue ?? context.payload.pull_request;
            if (!content) { core.info('No issue/PR in event'); return; }
            const contentId = content.node_id;
            let labels = (content.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            labels = labels.map(s => s.trim());

            // 2) Buscar el Project y sus campos (SIN Iteration para evitar el union)
            const qProject = `
              query($owner:String!, $title:String!) {
                user(login: $owner) {
                  projectsV2(first: 50, query: $title) {
                    nodes {
                      id
                      title
                      fields(first: 100) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                          ... on ProjectV2NumberField       { id name }
                          ... on ProjectV2TextField         { id name }
                          ... on ProjectV2DateField         { id name }
                        }
                      }
                    }
                  }
                }
              }
            }`;

            const prjRes = await github.graphql(qProject, { owner, title: projectTitle });
            const project = prjRes.user?.projectsV2?.nodes?.find(p => p.title === projectTitle);
            if (!project) {
              core.setFailed(`Project "${projectTitle}" not found for owner ${owner}.`);
              return;
            }

            const fields = project.fields.nodes;
            const F = (name) => fields.find(f => f.name === name);
            const F_TYPE = F('Type');
            const F_PRIORITY = F('Priority');
            const F_AREA = F('Area');
            const F_ESTIMATE = F('Estimate (pts)');

            // 3) Añadir el item al Project (idempotente)
            const addItemMut = `
              mutation($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                  item { id }
                }
              }`;
            let itemId;
            try {
              const addRes = await github.graphql(addItemMut, { projectId: project.id, contentId });
              itemId = addRes.addProjectV2ItemById.item.id;
            } catch (e) {
              // Si ya existe, intentamos localizar el item (best effort: reintento actualizando sin itemId no es posible)
              core.info(`addProjectV2ItemById: ${e.message}`);
              core.setFailed('El contenido ya podría estar en el Project; vuelve a etiquetar para reintentar.');
              return;
            }

            // Helpers de actualización
            const getSelectId = (field, name) => field?.options?.find(o => o.name === name)?.id;
            const updateSelect = async (field, optionId) => {
              if (!field || !optionId) return;
              const m = `
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$opt:String!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }) { projectV2Item { id } }
                }`;
              await github.graphql(m, { projectId: project.id, itemId, fieldId: field.id, opt: optionId });
            };
            const updateNumber = async (field, number) => {
              if (!field || number == null || Number.isNaN(number)) return;
              const m = `
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$num:Float!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ number:$num }
                  }) { projectV2Item { id } }
                }`;
              await github.graphql(m, { projectId: project.id, itemId, fieldId: field.id, num: Number(number) });
            };

            // 4) Mapeos de labels → valores
            const typeMap = {
              'type:feature': 'Feature',
              'type:spike':   'Spike',
              'type:task':    'Task',
              'type:bug':     'Bug',
              'type:chore':   'Chore'
            };
            const areaMap = {
              'area:app': 'App',
              'area:backend': 'Backend',
              'area:realtime': 'Realtime',
              'area:telemetry': 'Telemetry',
              'area:data': 'Data',
              'area:ux': 'UX',
              'area:ops': 'Ops'
            };

            // TYPE
            for (const [lbl, val] of Object.entries(typeMap)) {
              if (labels.includes(lbl)) {
                await updateSelect(F_TYPE, getSelectId(F_TYPE, val));
                break;
              }
            }

            // PRIORITY (labels prio:P0..P3)
            const prioLbl = labels.find(l => /^prio:P[0-3]$/i.test(l));
            if (prioLbl) {
              const prio = prioLbl.split(':')[1].toUpperCase(); // P0..P3
              await updateSelect(F_PRIORITY, getSelectId(F_PRIORITY, prio));
            }

            // AREA
            for (const [lbl, val] of Object.entries(areaMap)) {
              if (labels.includes(lbl)) {
                await updateSelect(F_AREA, getSelectId(F_AREA, val));
                break;
              }
            }

            // ESTIMATE (label estimate:X)
            const estLbl = labels.find(l => /^estimate:\d+$/i.test(l));
            if (estLbl) {
              const pts = Number(estLbl.split(':')[1]);
              await updateNumber(F_ESTIMATE, pts);
            }

            core.info('Item added/updated in Project with fields from labels (Type, Priority, Area, Estimate).');
