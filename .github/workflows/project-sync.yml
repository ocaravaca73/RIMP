name: Sync labels → Project fields (minimal)

on:
  workflow_dispatch:
  issues:
    types: [opened, edited, labeled, unlabeled]
  pull_request:
    types: [opened, edited, labeled, unlabeled]

jobs:
  sync:
    runs-on: ubuntu-latest
    environment: copilot   # usa secretos del entorno 'copilot'
    env:
      PROJECT_OWNER: ${{ github.repository_owner }}
      PROJECT_TITLE: RIMP – Product & Delivery
    steps:
      - name: Update Project fields from labels (Type, Priority)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.COPILOT_MCP_GITHUB_PROJECT_TOKEN }}  # PAT classic con scope 'project'
          script: |
            const owner = process.env.PROJECT_OWNER;
            const projectTitle = process.env.PROJECT_TITLE;
            const repo = context.repo.repo;

            // 1) Issue/PR del evento
            const content = context.payload.issue ?? context.payload.pull_request;
            if (!content) { core.info('No issue/PR in event; exit.'); return; }
            const contentId = content.node_id;

            // 2) Labels (con fallback REST por si vienen vacíos en el payload)
            let labels = (content.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            if (!labels.length) {
              const { data } = await github.rest.issues.listLabelsOnIssue({
                owner, repo, issue_number: content.number
              });
              labels = data.map(l => l.name);
            }
            labels = labels.map(s => s.trim());
            core.info(`Labels: ${labels.join(', ') || '(none)'}`);

            // 3) Buscar el Project y SOLO campos SingleSelect (evitamos unions)
            const qProject = `
              query($owner:String!, $title:String!) {
                user(login: $owner) {
                  projectsV2(first: 50, query: $title) {
                    nodes {
                      id
                      title
                      fields(first: 100) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }
              }`;
            const prjRes = await github.graphql(qProject, { owner, title: projectTitle });
            const project = prjRes.user?.projectsV2?.nodes?.find(p => p.title === projectTitle);
            if (!project) { core.setFailed(`Project "${projectTitle}" not found for owner ${owner}.`); return; }

            const fields = project.fields.nodes;
            const F = (name) => fields.find(f => f.name === name);
            const F_TYPE     = F('Type');
            const F_PRIORITY = F('Priority');
            if (!F_TYPE || !F_PRIORITY) {
              core.setFailed('Missing Project fields: ensure "Type" and "Priority" exist as Single-select.');
              return;
            }

            // 4) Localizar item existente en el Project
            const qFindItem = `
              query($contentId: ID!) {
                node(id: $contentId) {
                  __typename
                  ... on Issue {
                    projectItems(first: 50) { nodes { id project { id } } }
                  }
                  ... on PullRequest {
                    projectItems(first: 50) { nodes { id project { id } } }
                  }
                }
              }`;
            async function findExistingItemId() {
              const res = await github.graphql(qFindItem, { contentId });
              const items = res.node?.projectItems?.nodes || [];
              const hit = items.find(n => n.project?.id === project.id);
              return hit?.id;
            }

            // 5) Asegurar que el item está en el Project (añadir si no existe)
            async function ensureItemId() {
              let itemId = await findExistingItemId();
              if (itemId) return itemId;
              const addItemMut = `
                mutation($projectId:ID!, $contentId:ID!) {
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                    item { id }
                  }
                }`;
              try {
                const addRes = await github.graphql(addItemMut, { projectId: project.id, contentId });
                return addRes.addProjectV2ItemById.item.id;
              } catch (e) {
                core.info(`addProjectV2ItemById failed: ${e.message}`);
                itemId = await findExistingItemId();
                if (itemId) return itemId;
                core.setFailed('Could not add or locate the Project item for this content.');
                return null;
              }
            }
            const itemId = await ensureItemId();
            if (!itemId) return;

            // Helpers
            const getSelectId = (field, name) => field?.options?.find(o => o.name === name)?.id;
            const updateSelect = async (field, optionId) => {
              if (!field || !optionId) return;
              const m = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }) { projectV2Item { id } }
                }`;
              await github.graphql(m, { projectId:
