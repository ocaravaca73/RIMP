# RIMP Orchestrator (RFC01)
# ORCH_VERSION: 1.5.2  (2025-10-13)
# Changelog
#  - 1.5.2: TaskSpec-only flow + Injector/CommitPush/tests + emisión de ORCH_ERR:* (TAG_MISSING, MULTI_TAG, WI_MISSING,
#           STATE_INVALID, json, CI_CONFLICT, CI_FAIL, CHECKS). Mantiene lógica previa y compatibilidad 1.4.2.
#  - 1.4.2: Concurrency -> cancel-in-progress: true, multilines in err_list, PO:ACTION handling. (base)  [kept]

name: RIMP Orchestrator

on:
  repository_dispatch:
    types: [rimp.orch]

permissions:
  contents: write
  pull-requests: write

# Run only the latest orchestration per WI (avoid stale runs)
concurrency:
  group: orchestration-${{ github.event.client_payload.workItemId || github.event.client_payload.wi }}
  cancel-in-progress: true

env:
  ORCH_VERSION: "1.5.2"

  # RFC01 state machine
  ORCH_STATES: "ANALYSIS,IN_PROGRESS,READY_FOR_TEST,CHANGES_REQUESTED,READY_TO_MERGE,DONE"
  ORCH_EXEC_STATE: "IN_PROGRESS"

  # Azure Boards API (optional but recommended)
  AZDO_ORG_URL: ${{ secrets.AZDO_ORG_URL }}
  AZDO_PROJECT: ${{ secrets.AZDO_PROJECT }}
  AZDO_PAT: ${{ secrets.AZDO_PAT }}

jobs:
  gate:
    name: Gate (RFC01 validation)
    runs-on: ubuntu-latest
    outputs:
      proceed:   ${{ steps.decide.outputs.proceed }}
      reason:    ${{ steps.decide.outputs.reason }}
      wi:        ${{ steps.capture.outputs.WI }}
      title:     ${{ steps.capture.outputs.TITLE }}
      state:     ${{ steps.decide.outputs.state }}
      tags_all:  ${{ steps.capture.outputs.TAGS_ALL }}
      err_list:  ${{ steps.decide.outputs.err_list }}
      needsPO:   ${{ steps.decide.outputs.needsPO }}
    steps:
      - name: Version banner
        shell: bash
        run: echo "🔖 RIMP Orchestrator v${{ env.ORCH_VERSION }} (RFC01)"

      - name: Capture payload (unify tagsAll + orchTag + errors[])
        id: capture
        uses: actions/github-script@v8
        with:
          script: |
            // Read client payload
            const p = context.payload.client_payload || {};
            const wi    = String(p.workItemId || p.wi || '');
            const title = String(p.title || p.workItemTitle || '');
            const all   = String(p.tagsAll || p.tags || '');
            const one   = String(p.orchTag || '');
            const errs  = Array.isArray(p.errors) ? p.errors.filter(Boolean) : [];

            // Build TAGS_ALL
            const sep = ';';
            const set = new Set(all.split(sep).map(s => s.trim()).filter(Boolean));
            if (one) set.add(one.trim());
            for (const e of errs) if (e) set.add(String(e).trim());
            const TAGS_ALL = Array.from(set).join(sep);

            core.setOutput('WI', wi);
            core.setOutput('TITLE', title);
            core.setOutput('TAGS_ALL', TAGS_ALL);
            core.info(`Captured WI=${wi} | TAGS_ALL=${TAGS_ALL}`);

      - name: Decide according to RFC01
        id: decide
        shell: bash
        run: |
          set -e
          ALLOWED="${{ env.ORCH_STATES }}"
          EXEC_STATE="${{ env.ORCH_EXEC_STATE }}"
          TAGS_ALL="${{ steps.capture.outputs.TAGS_ALL }}"
          WI="${{ steps.capture.outputs.WI }}"

          norm_list() { echo "$1" | tr ',;|' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed '/^$/d'; }

          TAGS=$(norm_list "$TAGS_ALL")
          ERR_LIST="$(echo "$TAGS" | grep -i '^ORCH_ERR:' || true)"
          STATE_CANDIDATES="$(echo "$TAGS" | grep -i '^ORCH:' | grep -vi '^ORCH_ERR:' || true)"

          write_err_list() {
            {
              echo 'err_list<<ERRS'
              echo "$ERR_LIST"
              echo 'ERRS'
            } >> "$GITHUB_OUTPUT"
          }

          if [ -z "$WI" ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=Missing WI" >> "$GITHUB_OUTPUT"
            echo "state=" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          ALLOWED_REGEX="^($(echo "$ALLOWED" | tr ',' '|' | sed 's/[[:space:]]//g'))$"

          STATE_COUNT=$(echo "$STATE_CANDIDATES" | sed '/^$/d' | wc -l | tr -d ' ')
          if [ "$STATE_COUNT" -eq 0 ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=NO_STATE_TAG (missing ORCH:<STATE>)" >> "$GITHUB_OUTPUT"
            echo "state=" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$STATE_COUNT" -gt 1 ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=MULTI_STATE_TAG (more than one ORCH:<STATE>)" >> "$GITHUB_OUTPUT"
            echo "state=" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          RAW_STATE=$(echo "$STATE_CANDIDATES" | head -n1 | sed 's/^ORCH:\s*//I' | tr '[:lower:]' '[:upper:]')
          if ! echo "$RAW_STATE" | grep -Eq "$ALLOWED_REGEX"; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=STATE_NOT_ALLOWED ($RAW_STATE)" >> "$GITHUB_OUTPUT"
            echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "$ERR_LIST" ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=ERROR_TAGS_PRESENT" >> "$GITHUB_OUTPUT"
            echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$RAW_STATE" != "$EXEC_STATE" ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=STATE_OK_BUT_NO_EXEC ($RAW_STATE)" >> "$GITHUB_OUTPUT"
            echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
            ERR_LIST=""
            write_err_list
            echo "needsPO=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "proceed=true" >> "$GITHUB_OUTPUT"
          echo "reason=OK" >> "$GITHUB_OUTPUT"
          echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
          ERR_LIST=""
          write_err_list
          echo "needsPO=false" >> "$GITHUB_OUTPUT"

      - name: Gate summary
        shell: bash
        run: |
          echo "Gate: ${{ steps.decide.outputs.reason }}"
          echo "  Version: ${{ env.ORCH_VERSION }}"
          echo "  WI=${{ steps.capture.outputs.WI }}"
          echo "  STATE=${{ steps.decide.outputs.state }}"
          echo "  ERR_LIST<<EOF"; echo "${{ steps.decide.outputs.err_list }}"; echo "EOF"
          echo "  TAGS_ALL=${{ steps.capture.outputs.TAGS_ALL }}"
          echo "  needsPO=${{ steps.decide.outputs.needsPO }}"

  orchestrate:
    name: Orchestrate (IN_PROGRESS)
    needs: gate
    if: needs.gate.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Working variables
        shell: bash
        run: |
          echo "WI=${{ needs.gate.outputs.wi }}" >> $GITHUB_ENV
          echo "TITLE=${{ needs.gate.outputs.title || 'RIMP Task' }}" >> $GITHUB_ENV

      - name: Determine base branch
        id: base
        shell: bash
        run: |
          git fetch --all --prune
          if git rev-parse --verify origin/develop >/dev/null 2>&1; then
            echo "base=develop" >> $GITHUB_OUTPUT
          else
            echo "base=${{ github.event.repository.default_branch }}" >> $GITHUB_OUTPUT
          fi

      - name: Create or reuse branch
        id: br
        env:
          WI:   ${{ env.WI }}
          BASE: ${{ steps.base.outputs.base }}
        shell: bash
        run: |
          set -e
          BR="feature/AB${WI}-auto"
          echo "branch=$BR" >> $GITHUB_OUTPUT

          if git ls-remote --heads origin "$BR" | grep -q "$BR"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Existing branch: $BR"
            git switch "$BR"
            git merge --ff-only "origin/$BASE" || true
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            git config user.name "rimp-bot"
            git config user.email "rimp-bot@users.noreply.github.com"
            git switch -c "$BR" "origin/$BASE"
            mkdir -p .rimp
            echo "# keep" > .rimp/.keep
            git add .rimp/.keep
            git commit -m "chore: init branch for AB${WI}"
            git push -u origin "$BR"
            echo "Created $BR from $BASE."
          fi

      - name: Create or reuse PR (draft)
        uses: actions/github-script@v8
        env:
          WI:     ${{ env.WI }}
          BRANCH: ${{ steps.br.outputs.branch }}
          BASE:   ${{ steps.base.outputs.base }}
          TITLE:  ${{ env.TITLE }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const head  = `${owner}:${process.env.BRANCH}`;
            const base  = process.env.BASE;
            const wi    = process.env.WI;
            const title = `AB#${wi}: ${process.env.TITLE || '(no title)'}`.slice(0, 240);

            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head });
            if (prs.data.length > 0) {
              core.info(`PR already exists: #${prs.data[0].number}`);
            } else {
              const pr = await github.rest.pulls.create({
                owner, repo, head: process.env.BRANCH, base, title, draft: true,
                body: `Auto-created for AB#${wi} (state ORCH:IN_PROGRESS).`
              });
              core.info(`PR created: #${pr.data.number}`);
            }

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Ensure tools exist
        shell: bash
        run: |
          test -f ".github/tools/Injector/Injector.csproj" || { echo "Missing Injector tool"; exit 2; }
          test -f ".github/tools/CommitPush/CommitPush.csproj" || { echo "Missing CommitPush tool"; exit 2; }

      # --- TaskSpec-only: require plan/taskspec.json in feature/AB<WI>-auto ---
      - name: Check TaskSpec presence & validity
        id: taskspec
        shell: bash
        run: |
          set -e
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update && sudo apt-get install -y jq >/dev/null; fi
          if [ ! -f "plan/taskspec.json" ]; then
            echo "present=false" >> $GITHUB_OUTPUT
            echo "reason=MISSING" >> $GITHUB_OUTPUT
            exit 0
          fi
          if ! jq -e 'type=="object" and ((.files//[]) + (.tests//[])) | length > 0' plan/taskspec.json >/dev/null 2>&1; then
            echo "present=false" >> $GITHUB_OUTPUT
            echo "reason=INVALID" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "present=true" >> $GITHUB_OUTPUT
          echo "reason=OK" >> $GITHUB_OUTPUT
          jq . plan/taskspec.json | head -n 50

      - name: Report missing/invalid TaskSpec (PR comment)
        if: steps.taskspec.outputs.present != 'true'
        uses: actions/github-script@v8
        env:
          WI:     ${{ env.WI }}
          REASON: ${{ steps.taskspec.outputs.reason }}
        with:
          script: |
            const owner=context.repo.owner, repo=context.repo.repo, wi=process.env.WI, reason=process.env.REASON||'MISSING';
            const head=`${owner}:feature/AB${wi}-auto`;
            const prs=await github.rest.pulls.list({ owner, repo, state:'open', head });
            const pr=prs.data[0]; if(!pr) { core.info('No PR to comment'); } else {
              const body = `❌ TaskSpec ${reason}. Please add **plan/taskspec.json** to branch \`feature/AB${wi}-auto\`.\n`+
                           `Expected: JSON with arrays **files/tests** (>=1 total).`;
              await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body });
            }

      - name: Add tag ORCH_ERR:json in Azure Boards (optional)
        if: steps.taskspec.outputs.present != 'true' && env.AZDO_ORG_URL != '' && env.AZDO_PROJECT != '' && env.AZDO_PAT != ''
        uses: actions/github-script@v8
        env:
          WI: ${{ env.WI }}
        with:
          script: |
            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;
            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');

            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers:{Authorization:auth}});
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t=>t.trim()).filter(Boolean);
            if (!list.includes('ORCH_ERR:json')) list.push('ORCH_ERR:json');
            const value = list.join(';');
            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            const patch = [{ op:'add', path:'/fields/System.Tags', value }];
            const r2 = await fetch(patchUrl, { method:'PATCH', headers:{Authorization:auth,'Content-Type':'application/json-patch+json'}, body: JSON.stringify(patch) });
            if (!r2.ok) core.warning(`PATCH (add ORCH_ERR:json) failed: ${r2.status}`);

      - name: Stop (no TaskSpec)
        if: steps.taskspec.outputs.present != 'true'
        run: |
          echo "Stopping run because TaskSpec is missing/invalid."
          exit 1

      # Early detection of merge conflicts on PR head → ORCH_ERR:CI_CONFLICT
      - name: Detect merge conflicts (tag ORCH_ERR:CI_CONFLICT)
        uses: actions/github-script@v8
        env:
          WI:     ${{ env.WI }}
          BRANCH: ${{ steps.br.outputs.branch }}
        with:
          script: |
            const owner=context.repo.owner, repo=context.repo.repo, wi=process.env.WI, head=process.env.BRANCH;
            let prs=await github.rest.pulls.list({ owner, repo, state:'open', head: `${owner}:${head}` });
            const pr=prs.data[0]; if(!pr){ core.info('No PR found'); return; }

            // mergeable can be null initially; poll a bit
            let mergeable = pr.mergeable;
            for (let i=0;i<5 && mergeable === null;i++){
              await new Promise(r=>setTimeout(r,1500));
              const pr2 = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
              mergeable = pr2.data.mergeable;
            }
            if (mergeable === false) {
              core.warning('Merge conflicts detected.');
              if (process.env.AZDO_ORG_URL && process.env.AZDO_PROJECT && process.env.AZDO_PAT) {
                const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
                const proj = process.env.AZDO_PROJECT;
                const pat  = process.env.AZDO_PAT;
                const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');
                const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
                const r1 = await fetch(getUrl, { headers:{Authorization:auth}});
                if (r1.ok) {
                  const js = await r1.json();
                  const cur = String(js.fields?.['System.Tags'] || '');
                  const list = cur.split(';').map(t=>t.trim()).filter(Boolean);
                  if (!list.includes('ORCH_ERR:CI_CONFLICT')) list.push('ORCH_ERR:CI_CONFLICT');
                  const value = list.join(';');
                  const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
                  await fetch(patchUrl, { method:'PATCH', headers:{Authorization:auth,'Content-Type':'application/json-patch+json'}, body: JSON.stringify([{op:'add',path:'/fields/System.Tags',value}]) });
                }
              }
              core.setFailed('Merge conflicts detected');
            }

      - name: Inject (generate code + tests from TaskSpec)
        run: dotnet run --project .github/tools/Injector/Injector.csproj -- --taskspec plan/taskspec.json --dry-run false

      - name: Commit & Push (Octokit)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: dotnet run --project .github/tools/CommitPush/CommitPush.csproj -- --branch "${{ steps.br.outputs.branch }}" --message "AB#${{ env.WI }} · auto-inject" --manifest plan/manifest.txt

      - name: Restore/Build/Test
        run: |
          dotnet restore
          dotnet build -c Release
          dotnet test -c Release --logger trx --results-directory test-results

      - name: Publish test artifacts
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results

      - name: Tag ORCH_ERR:CI_FAIL on build/test failure
        if: failure()
        uses: actions/github-script@v8
        env:
          WI: ${{ env.WI }}
        with:
          script: |
            if (!(process.env.AZDO_ORG_URL && process.env.AZDO_PROJECT && process.env.AZDO_PAT)) { core.info('No ADO creds'); return; }
            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;
            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');

            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers:{Authorization:auth}});
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t=>t.trim()).filter(Boolean);
            if (!list.includes('ORCH_ERR:CI_FAIL')) list.push('ORCH_ERR:CI_FAIL');
            const value = list.join(';');

            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            const patch = [{ op:'add', path:'/fields/System.Tags', value }];
            const r2 = await fetch(patchUrl, { method:'PATCH', headers:{Authorization:auth,'Content-Type':'application/json-patch+json'}, body: JSON.stringify(patch) });
            if (!r2.ok) core.warning(`PATCH (add ORCH_ERR:CI_FAIL) failed: ${r2.status}`);

      - name: If green → set ORCH:READY_FOR_TEST in Azure Boards
        if: ${{ success() && env.AZDO_ORG_URL != '' && env.AZDO_PROJECT != '' && env.AZDO_PAT != '' }}
        uses: actions/github-script@v8
        env:
          WI: ${{ env.WI }}
        with:
          script: |
            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;
            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');
            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers: { Authorization: auth } });
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t=>t.trim()).filter(Boolean).filter(t=>!/^ORCH:/i.test(t));
            list.push('ORCH:READY_FOR_TEST');
            const value = list.join(';');
            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            const patch = [{ op:'add', path:'/fields/System.Tags', value }];
            await fetch(patchUrl, { method:'PATCH', headers:{ Authorization:auth, 'Content-Type':'application/json-patch+json' }, body: JSON.stringify(patch) });

      - name: Remove PO:ACTION tag in Azure Boards (if present)
        if: ${{ env.AZDO_ORG_URL != '' && env.AZDO_PROJECT != '' && env.AZDO_PAT != '' }}
        uses: actions/github-script@v8
        env:
          WI: ${{ env.WI }}
        with:
          script: |
            // Remove "PO:ACTION" from System.Tags (idempotent)
            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;

            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');
            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers: { Authorization: auth }});
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t => t.trim()).filter(Boolean).filter(t => t !== 'PO:ACTION');
            const value = list.join(';');

            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            const patch = [{ op: 'add', path: '/fields/System.Tags', value }];
            const r2 = await fetch(patchUrl, {
              method: 'PATCH',
              headers: { 'Authorization': auth, 'Content-Type': 'application/json-patch+json' },
              body: JSON.stringify(patch)
            });
            if (!r2.ok) core.warning(`PATCH (remove PO:ACTION) failed: ${r2.status}`);

  report_when_blocked:
    name: Report (when gate blocks)
    needs: gate
    if: needs.gate.outputs.proceed != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Comment on PR (if any)
        uses: actions/github-script@v8
        env:
          WI:       ${{ needs.gate.outputs.wi }}
          REASON:   ${{ needs.gate.outputs.reason }}
          STATE:    ${{ needs.gate.outputs.state }}
          ERR_LIST: ${{ needs.gate.outputs.err_list }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const wi    = process.env.WI;

            const head = `${owner}:feature/AB${wi}-auto`;
            let prs = await github.rest.pulls.list({ owner, repo, state: 'open', head });
            let pr  = prs.data[0];
            if (!pr) {
              prs = await github.rest.pulls.list({ owner, repo, state: 'open' });
              pr = prs.data.find(p => p.title.includes(`AB#${wi}`));
            }
            if (!pr) { core.info(`No open PR for AB#${wi}; nothing to comment.`); return; }

            const reason = process.env.REASON || 'Gate blocked';
            const state  = process.env.STATE || '(no state)';
            const errs   = (process.env.ERR_LIST || '').split('\n').filter(Boolean);

            let body = [
              '⚠️ Orchestration blocked by the gate.',
              '',
              `- **WI**: AB#${wi}`,
              `- **ORCH state**: ${state}`,
              `- **Reason**: ${reason}`
            ].join('\n');
            if (errs.length) body += '\n- **Errors**:\n' + errs.map(e => `  - ${e}`).join('\n') + '\n';

            await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body });
            core.info(`Comment posted on PR #${pr.number}: ${reason}`);

      # Emit ORCH_ERR:* in ADO based on gate reason
      - name: Tag ORCH_ERR from gate reason (WI_MISSING, TAG_MISSING, MULTI_TAG, STATE_INVALID)
        if: env.AZDO_ORG_URL != '' && env.AZDO_PROJECT != '' && env.AZDO_PAT != ''
        uses: actions/github-script@v8
        env:
          WI:     ${{ needs.gate.outputs.wi }}
          REASON: ${{ needs.gate.outputs.reason }}
        with:
          script: |
            const reason = (process.env.REASON || '').toUpperCase();
            let errTag = null;
            if (reason.startsWith('MISSING WI')) errTag = 'ORCH_ERR:WI_MISSING';
            if (reason.startsWith('NO_STATE_TAG')) errTag = 'ORCH_ERR:TAG_MISSING';
            if (reason.startsWith('MULTI_STATE_TAG')) errTag = 'ORCH_ERR:MULTI_TAG';
            if (reason.startsWith('STATE_NOT_ALLOWED')) errTag = 'ORCH_ERR:STATE_INVALID';
            if (!errTag) { core.info(`No ORCH_ERR mapping for reason=${reason}`); return; }

            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;
            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');

            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers:{Authorization:auth}});
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t=>t.trim()).filter(Boolean);
            if (!list.includes(errTag)) list.push(errTag);
            const value = list.join(';');

            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            await fetch(patchUrl, { method:'PATCH', headers:{Authorization:auth,'Content-Type':'application/json-patch+json'}, body: JSON.stringify([{op:'add',path:'/fields/System.Tags',value}]) });

      - name: Ensure PO:ACTION tag in Azure Boards (PO radar)
        if: ${{ needs.gate.outputs.needsPO == 'true' && env.AZDO_ORG_URL != '' && env.AZDO_PROJECT != '' && env.AZDO_PAT != '' }}
        uses: actions/github-script@v8
        env:
          WI: ${{ needs.gate.outputs.wi }}
        with:
          script: |
            // Add "PO:ACTION" to System.Tags (idempotent)
            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;

            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');
            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers: { Authorization: auth }});
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t => t.trim()).filter(Boolean);
            if (!list.includes('PO:ACTION')) list.push('PO:ACTION');
            const value = list.join(';');

            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            const patch = [{ op: 'add', path: '/fields/System.Tags', value }];
            const r2 = await fetch(patchUrl, {
              method: 'PATCH',
              headers: { 'Authorization': auth, 'Content-Type': 'application/json-patch+json' },
              body: JSON.stringify(patch)
            });
            if (!r2.ok) core.warning(`PATCH (add PO:ACTION) failed: ${r2.status}"); else core.info('PO:ACTION tag ensured.')
