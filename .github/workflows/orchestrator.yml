# RIMP Orchestrator (RFC01)
# ORCH_VERSION: 1.4.2  (2025-10-10)
# Changelog
#  - 1.4.2: Concurrency -> cancel-in-progress: true (ensures latest WI update wins; avoids stale runs re-adding PO:ACTION).
#  - 1.4.1: Fix multiline output for err_list (supports multiple ORCH_ERR:*).
#  - 1.4.0: Version banner; PO:ACTION ensure/remove (Azure Boards); robust tags merge; strict gate; PR comment in English.

name: RIMP Orchestrator

on:
  repository_dispatch:
    types: [rimp.orch]

permissions:
  contents: write
  pull-requests: write

# Run only the latest orchestration per WI (avoid stale runs)
concurrency:
  group: orchestration-${{ github.event.client_payload.workItemId || github.event.client_payload.wi }}
  cancel-in-progress: true

env:
  ORCH_VERSION: "1.4.2"

  # RFC01 state machine
  ORCH_STATES: "ANALYSIS,IN_PROGRESS,READY_FOR_TEST,CHANGES_REQUESTED,READY_TO_MERGE,DONE"
  ORCH_EXEC_STATE: "IN_PROGRESS"

  # Azure Boards API (configure as repo/org secrets)
  AZDO_ORG_URL: ${{ secrets.AZDO_ORG_URL }}
  AZDO_PROJECT: ${{ secrets.AZDO_PROJECT }}
  AZDO_PAT: ${{ secrets.AZDO_PAT }}

jobs:
  gate:
    name: Gate (RFC01 validation)
    runs-on: ubuntu-latest
    outputs:
      proceed:   ${{ steps.decide.outputs.proceed }}
      reason:    ${{ steps.decide.outputs.reason }}
      wi:        ${{ steps.capture.outputs.WI }}
      title:     ${{ steps.capture.outputs.TITLE }}
      state:     ${{ steps.decide.outputs.state }}
      tags_all:  ${{ steps.capture.outputs.TAGS_ALL }}
      err_list:  ${{ steps.decide.outputs.err_list }}
      needsPO:   ${{ steps.decide.outputs.needsPO }}
    steps:
      - name: Version banner
        shell: bash
        run: echo "🔖 RIMP Orchestrator v${{ env.ORCH_VERSION }} (RFC01)"

      - name: Capture payload (unify tagsAll + orchTag + errors[])
        id: capture
        uses: actions/github-script@v8
        with:
          script: |
            // Read client payload
            const p = context.payload.client_payload || {};
            const wi    = String(p.workItemId || p.wi || '');
            const title = String(p.title || p.workItemTitle || '');
            const all   = String(p.tagsAll || p.tags || '');
            const one   = String(p.orchTag || '');
            const errs  = Array.isArray(p.errors) ? p.errors.filter(Boolean) : [];

            // Build TAGS_ALL
            const sep = ';';
            const set = new Set(all.split(sep).map(s => s.trim()).filter(Boolean));
            if (one) set.add(one.trim());
            for (const e of errs) if (e) set.add(String(e).trim());
            const TAGS_ALL = Array.from(set).join(sep);

            core.setOutput('WI', wi);
            core.setOutput('TITLE', title);
            core.setOutput('TAGS_ALL', TAGS_ALL);
            core.info(`Captured WI=${wi} | TAGS_ALL=${TAGS_ALL}`);

      - name: Decide according to RFC01
        id: decide
        shell: bash
        run: |
          set -e
          ALLOWED="${{ env.ORCH_STATES }}"
          EXEC_STATE="${{ env.ORCH_EXEC_STATE }}"
          TAGS_ALL="${{ steps.capture.outputs.TAGS_ALL }}"
          WI="${{ steps.capture.outputs.WI }}"

          norm_list() { echo "$1" | tr ',;|' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed '/^$/d'; }

          TAGS=$(norm_list "$TAGS_ALL")
          ERR_LIST="$(echo "$TAGS" | grep -i '^ORCH_ERR:' || true)"
          STATE_CANDIDATES="$(echo "$TAGS" | grep -i '^ORCH:' | grep -vi '^ORCH_ERR:' || true)"

          write_err_list() {
            {
              echo 'err_list<<ERRS'
              echo "$ERR_LIST"
              echo 'ERRS'
            } >> "$GITHUB_OUTPUT"
          }

          if [ -z "$WI" ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=Missing WI" >> "$GITHUB_OUTPUT"
            echo "state=" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          ALLOWED_REGEX="^($(echo "$ALLOWED" | tr ',' '|' | sed 's/[[:space:]]//g'))$"

          STATE_COUNT=$(echo "$STATE_CANDIDATES" | sed '/^$/d' | wc -l | tr -d ' ')
          if [ "$STATE_COUNT" -eq 0 ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=NO_STATE_TAG (missing ORCH:<STATE>)" >> "$GITHUB_OUTPUT"
            echo "state=" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$STATE_COUNT" -gt 1 ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=MULTI_STATE_TAG (more than one ORCH:<STATE>)" >> "$GITHUB_OUTPUT"
            echo "state=" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          RAW_STATE=$(echo "$STATE_CANDIDATES" | head -n1 | sed 's/^ORCH:\s*//I' | tr '[:lower:]' '[:upper:]')
          if ! echo "$RAW_STATE" | grep -Eq "$ALLOWED_REGEX"; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=STATE_NOT_ALLOWED ($RAW_STATE)" >> "$GITHUB_OUTPUT"
            echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "$ERR_LIST" ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=ERROR_TAGS_PRESENT" >> "$GITHUB_OUTPUT"
            echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
            write_err_list
            echo "needsPO=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$RAW_STATE" != "$EXEC_STATE" ]; then
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "reason=STATE_OK_BUT_NO_EXEC ($RAW_STATE)" >> "$GITHUB_OUTPUT"
            echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
            ERR_LIST=""
            write_err_list
            echo "needsPO=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "proceed=true" >> "$GITHUB_OUTPUT"
          echo "reason=OK" >> "$GITHUB_OUTPUT"
          echo "state=$RAW_STATE" >> "$GITHUB_OUTPUT"
          ERR_LIST=""
          write_err_list
          echo "needsPO=false" >> "$GITHUB_OUTPUT"

      - name: Gate summary
        shell: bash
        run: |
          echo "Gate: ${{ steps.decide.outputs.reason }}"
          echo "  Version: ${{ env.ORCH_VERSION }}"
          echo "  WI=${{ steps.capture.outputs.WI }}"
          echo "  STATE=${{ steps.decide.outputs.state }}"
          echo "  ERR_LIST<<EOF"; echo "${{ steps.decide.outputs.err_list }}"; echo "EOF"
          echo "  TAGS_ALL=${{ steps.capture.outputs.TAGS_ALL }}"
          echo "  needsPO=${{ steps.decide.outputs.needsPO }}"

  orchestrate:
    name: Orchestrate (IN_PROGRESS)
    needs: gate
    if: needs.gate.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Working variables
        shell: bash
        run: |
          echo "WI=${{ needs.gate.outputs.wi }}" >> $GITHUB_ENV
          echo "TITLE=${{ needs.gate.outputs.title || 'RIMP Task' }}" >> $GITHUB_ENV

      - name: Determine base branch
        id: base
        shell: bash
        run: |
          git fetch --all --prune
          if git rev-parse --verify origin/develop >/dev/null 2>&1; then
            echo "base=develop" >> $GITHUB_OUTPUT
          else
            echo "base=${{ github.event.repository.default_branch }}" >> $GITHUB_OUTPUT
          fi

      - name: Create or reuse branch
        id: br
        env:
          WI:   ${{ env.WI }}
          BASE: ${{ steps.base.outputs.base }}
        shell: bash
        run: |
          set -e
          BR="feature/AB${WI}-auto"
          echo "branch=$BR" >> $GITHUB_OUTPUT

          if git ls-remote --heads origin "$BR" | grep -q "$BR"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Existing branch: $BR"
            git switch "$BR"
            git merge --ff-only "origin/$BASE" || true
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            git config user.name "rimp-bot"
            git config user.email "rimp-bot@users.noreply.github.com"
            git switch -c "$BR" "origin/$BASE"
            mkdir -p .rimp
            echo "# keep" > .rimp/.keep
            git add .rimp/.keep
            git commit -m "chore: init branch for AB${WI}"
            git push -u origin "$BR"
            echo "Created $BR from $BASE."
          fi

      - name: Create or reuse PR (draft)
        uses: actions/github-script@v8
        env:
          WI:     ${{ env.WI }}
          BRANCH: ${{ steps.br.outputs.branch }}
          BASE:   ${{ steps.base.outputs.base }}
          TITLE:  ${{ env.TITLE }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const head  = `${owner}:${process.env.BRANCH}`;
            const base  = process.env.BASE;
            const wi    = process.env.WI;
            const title = `AB#${wi}: ${process.env.TITLE || '(no title)'}`.slice(0, 240);

            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head });
            if (prs.data.length > 0) {
              core.info(`PR already exists: #${prs.data[0].number}`);
            } else {
              const pr = await github.rest.pulls.create({
                owner, repo, head: process.env.BRANCH, base, title, draft: true,
                body: `Auto-created for AB#${wi} (state ORCH:IN_PROGRESS).`
              });
              core.info(`PR created: #${pr.data.number}`);
            }

      - name: Remove PO:ACTION tag in Azure Boards (if present)
        if: ${{ env.AZDO_ORG_URL != '' && env.AZDO_PROJECT != '' && env.AZDO_PAT != '' }}
        uses: actions/github-script@v8
        env:
          WI: ${{ env.WI }}
        with:
          script: |
            // Remove "PO:ACTION" from System.Tags (idempotent)
            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;

            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');
            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers: { Authorization: auth }});
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t => t.trim()).filter(Boolean).filter(t => t !== 'PO:ACTION');
            const value = list.join(';');

            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            const patch = [{ op: 'add', path: '/fields/System.Tags', value }];
            const r2 = await fetch(patchUrl, {
              method: 'PATCH',
              headers: { 'Authorization': auth, 'Content-Type': 'application/json-patch+json' },
              body: JSON.stringify(patch)
            });
            if (!r2.ok) core.warning(`PATCH (remove PO:ACTION) failed: ${r2.status}`);

  report_when_blocked:
    name: Report (when gate blocks)
    needs: gate
    if: needs.gate.outputs.proceed != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Comment on PR (if any)
        uses: actions/github-script@v8
        env:
          WI:       ${{ needs.gate.outputs.wi }}
          REASON:   ${{ needs.gate.outputs.reason }}
          STATE:    ${{ needs.gate.outputs.state }}
          ERR_LIST: ${{ needs.gate.outputs.err_list }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const wi    = process.env.WI;

            const head = `${owner}:feature/AB${wi}-auto`;
            let prs = await github.rest.pulls.list({ owner, repo, state: 'open', head });
            let pr  = prs.data[0];
            if (!pr) {
              prs = await github.rest.pulls.list({ owner, repo, state: 'open' });
              pr = prs.data.find(p => p.title.includes(`AB#${wi}`));
            }
            if (!pr) { core.info(`No open PR for AB#${wi}; nothing to comment.`); return; }

            const reason = process.env.REASON || 'Gate blocked';
            const state  = process.env.STATE || '(no state)';
            const errs   = (process.env.ERR_LIST || '').split('\n').filter(Boolean);

            let body = [
              '⚠️ Orchestration blocked by the gate.',
              '',
              `- **WI**: AB#${wi}`,
              `- **ORCH state**: ${state}`,
              `- **Reason**: ${reason}`
            ].join('\n');
            if (errs.length) body += '\n- **Errors**:\n' + errs.map(e => `  - ${e}`).join('\n') + '\n';

            await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body });
            core.info(`Comment posted on PR #${pr.number}: ${reason}`);

      - name: Ensure PO:ACTION tag in Azure Boards (PO radar)
        if: ${{ needs.gate.outputs.needsPO == 'true' && env.AZDO_ORG_URL != '' && env.AZDO_PROJECT != '' && env.AZDO_PAT != '' }}
        uses: actions/github-script@v8
        env:
          WI: ${{ needs.gate.outputs.wi }}
        with:
          script: |
            // Add "PO:ACTION" to System.Tags (idempotent)
            const org  = process.env.AZDO_ORG_URL.replace(/\/$/, '');
            const proj = process.env.AZDO_PROJECT;
            const wi   = process.env.WI;
            const pat  = process.env.AZDO_PAT;

            const auth = 'Basic ' + Buffer.from(':'+pat).toString('base64');
            const getUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?fields=System.Tags&api-version=7.0`;
            const r1 = await fetch(getUrl, { headers: { Authorization: auth }});
            if (!r1.ok) { core.warning(`GET WI failed: ${r1.status}`); return; }
            const js = await r1.json();
            const cur = String(js.fields?.['System.Tags'] || '');
            const list = cur.split(';').map(t => t.trim()).filter(Boolean);
            if (!list.includes('PO:ACTION')) list.push('PO:ACTION');
            const value = list.join(';');

            const patchUrl = `${org}/${proj}/_apis/wit/workitems/${wi}?api-version=7.0`;
            const patch = [{ op: 'add', path: '/fields/System.Tags', value }];
            const r2 = await fetch(patchUrl, {
              method: 'PATCH',
              headers: { 'Authorization': auth, 'Content-Type': 'application/json-patch+json' },
              body: JSON.stringify(patch)
            });
            if (!r2.ok) core.warning(`PATCH (add PO:ACTION) failed: ${r2.status}");
            else core.info('PO:ACTION tag ensured.')
