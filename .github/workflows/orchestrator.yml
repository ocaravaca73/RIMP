name: RIMP Orchestrator

on:
  # Debe coincidir con el evento que envía el Worker (DISPATCH_EVENT = rimp.orch)
  repository_dispatch:
    types: [rimp.orch]

permissions:
  contents: write
  pull-requests: write

# Evita carreras duplicadas por el mismo Work Item (acepta wi o workItemId)
concurrency:
  group: orchestration-${{ github.event.client_payload.workItemId || github.event.client_payload.wi }}
  cancel-in-progress: false

env:
  # Estados de RFC01 aceptados para ORCH:<STATE>
  ORCH_STATES: "ANALYSIS,IN_PROGRESS,READY_FOR_TEST,CHANGES_REQUESTED,READY_TO_MERGE,DONE"
  # Estado que permite ejecutar la orquestación “fuerte” (crear/reutilizar rama/PR)
  ORCH_EXEC_STATE: "IN_PROGRESS"

jobs:
  gate:
    name: Gate (validación RFC01)
    runs-on: ubuntu-latest
    outputs:
      proceed:   ${{ steps.decide.outputs.proceed }}
      reason:    ${{ steps.decide.outputs.reason }}
      wi:        ${{ steps.capture.outputs.WI }}
      title:     ${{ steps.capture.outputs.TITLE }}
      state:     ${{ steps.decide.outputs.state }}
      tags_all:  ${{ steps.capture.outputs.TAGS_ALL }}
      err_list:  ${{ steps.decide.outputs.err_list }}
    steps:
      - name: Capturar payload (compat)
        id: capture
        shell: bash
        run: |
          set -e
          # IDs y título
          echo "WI=${{ github.event.client_payload.workItemId || github.event.client_payload.wi }}" >> $GITHUB_OUTPUT
          echo "TITLE<<EOF" >> $GITHUB_OUTPUT
          echo "${{ github.event.client_payload.title || github.event.client_payload.workItemTitle || '' }}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Tags: prioriza orchTag (uno), luego tags/tagsAll (cadena)
          TAGS_ONE="${{ github.event.client_payload.orchTag || '' }}"
          TAGS_STR="${{ github.event.client_payload.tags || github.event.client_payload.tagsAll || '' }}"
          if [ -n "$TAGS_ONE" ]; then
            TAGS_JOINED="$TAGS_ONE"
          else
            TAGS_JOINED="$TAGS_STR"
          fi

          # Errors[] como lista separada por ';' si viene
          ERR_JOINED="${{ github.event.client_payload.errors && join(github.event.client_payload.errors, ';') || '' }}"

          # Ensambla TAGS_ALL = tags + errores
          if [ -n "$ERR_JOINED" ]; then
            if [ -n "$TAGS_JOINED" ]; then
              TAGS_ALL="$TAGS_JOINED;$ERR_JOINED"
            else
              TAGS_ALL="$ERR_JOINED"
            fi
          else
            TAGS_ALL="$TAGS_JOINED"
          fi

          echo "TAGS_ALL=${TAGS_ALL}" >> $GITHUB_OUTPUT

          echo "Payload capturado:"
          echo "  WI=$WI"
          echo "  TITLE=$(echo "${{ github.event.client_payload.title || github.event.client_payload.workItemTitle || '' }}" | head -c 120)"
          echo "  TAGS_ALL=$TAGS_ALL"

      - name: Decidir según RFC01
        id: decide
        shell: bash
        run: |
          set -e
          ALLOWED="${{ env.ORCH_STATES }}"
          EXEC_STATE="${{ env.ORCH_EXEC_STATE }}"
          TAGS_ALL="${{ steps.capture.outputs.TAGS_ALL }}"
          WI="${{ steps.capture.outputs.WI }}"

          norm_list() { echo "$1" | tr ',;|' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed '/^$/d'; }

          TAGS=$(norm_list "$TAGS_ALL")
          # Separa ORCH_ERR:* (errores) y ORCH:<STATE> (estado)
          ERR_LIST=$(echo "$TAGS" | grep -i '^ORCH_ERR:' || true)
          STATE_CANDIDATES=$(echo "$TAGS" | grep -i '^ORCH:' | grep -vi '^ORCH_ERR:' || true)

          # Validaciones
          if [ -z "$WI" ]; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "reason=Missing WI" >> $GITHUB_OUTPUT
            echo "state=" >> $GITHUB_OUTPUT
            echo "err_list=$ERR_LIST" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Normaliza estados permitidos
          ALLOWED_REGEX="^($(echo "$ALLOWED" | tr ',' '|' | sed 's/[[:space:]]//g'))$"

          # Extrae el único estado si existe
          STATE_COUNT=$(echo "$STATE_CANDIDATES" | sed '/^$/d' | wc -l | tr -d ' ')
          if [ "$STATE_COUNT" -eq 0 ]; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "reason=NO_STATE_TAG (falta ORCH:<STATE>)" >> $GITHUB_OUTPUT
            echo "state=" >> $GITHUB_OUTPUT
            echo "err_list=$ERR_LIST" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ "$STATE_COUNT" -gt 1 ]; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "reason=MULTI_STATE_TAG (más de un ORCH:<STATE>)" >> $GITHUB_OUTPUT
            echo "state=" >> $GITHUB_OUTPUT
            echo "err_list=$ERR_LIST" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Estado único normalizado (mayúsculas, sin 'ORCH:')
          RAW_STATE=$(echo "$STATE_CANDIDATES" | head -n1 | sed 's/^ORCH:\s*//I' | tr '[:lower:]' '[:upper:]')
          if ! echo "$RAW_STATE" | grep -Eq "$ALLOWED_REGEX"; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "reason=STATE_NOT_ALLOWED ($RAW_STATE)" >> $GITHUB_OUTPUT
            echo "state=$RAW_STATE" >> $GITHUB_OUTPUT
            echo "err_list=$ERR_LIST" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Si hay errores, no avanzamos (se reportará)
          if [ -n "$ERR_LIST" ]; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "reason=ERROR_TAGS_PRESENT" >> $GITHUB_OUTPUT
            echo "state=$RAW_STATE" >> $GITHUB_OUTPUT
            echo "err_list=$ERR_LIST" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Avanza solo si el estado es el ejecutable (IN_PROGRESS)
          if [ "$RAW_STATE" != "$EXEC_STATE" ]; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            echo "reason=STATE_OK_BUT_NO_EXEC ($RAW_STATE)" >> $GITHUB_OUTPUT
            echo "state=$RAW_STATE" >> $GITHUB_OUTPUT
            echo "err_list=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "proceed=true" >> $GITHUB_OUTPUT
          echo "reason=OK" >> $GITHUB_OUTPUT
          echo "state=$RAW_STATE" >> $GITHUB_OUTPUT
          echo "err_list=" >> $GITHUB_OUTPUT

      - name: Log del gate
        shell: bash
        run: |
          echo "Gate: ${{ steps.decide.outputs.reason }}"
          echo "  WI=${{ steps.capture.outputs.WI }}"
          echo "  STATE=${{ steps.decide.outputs.state }}"
          echo "  ERR_LIST=${{ steps.decide.outputs.err_list }}"
          echo "  TAGS_ALL=${{ steps.capture.outputs.TAGS_ALL }}"

  orchestrate:
    name: Orquestar (IN_PROGRESS)
    needs: gate
    if: needs.gate.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Variables de trabajo
        shell: bash
        run: |
          echo "WI=${{ needs.gate.outputs.wi }}" >> $GITHUB_ENV
          echo "TITLE=${{ needs.gate.outputs.title || 'RIMP Task' }}" >> $GITHUB_ENV

      - name: Determinar rama base
        id: base
        shell: bash
        run: |
          git fetch --all --prune
          # Usa develop si existe, si no, el default del repo
          if git rev-parse --verify origin/develop >/dev/null 2>&1; then
            echo "base=develop" >> $GITHUB_OUTPUT
          else
            echo "base=${{ github.event.repository.default_branch }}" >> $GITHUB_OUTPUT
          fi

      - name: Crear o reutilizar rama
        id: br
        env:
          WI:   ${{ env.WI }}
          BASE: ${{ steps.base.outputs.base }}
        shell: bash
        run: |
          set -e
          BR="feature/AB${WI}-auto"
          echo "branch=$BR" >> $GITHUB_OUTPUT

          # ¿Existe en remoto?
          if git ls-remote --heads origin "$BR" | grep -q "$BR"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Rama existente: $BR"
            git switch "$BR"
            git merge --ff-only "origin/$BASE" || true
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            git config user.name "rimp-bot"
            git config user.email "rimp-bot@users.noreply.github.com"
            git switch -c "$BR" "origin/$BASE"
            mkdir -p .rimp
            echo "# keep" > .rimp/.keep
            git add .rimp/.keep
            git commit -m "chore: init branch for AB${WI}"
            git push -u origin "$BR"
            echo "Creada rama $BR desde $BASE."
          fi

      - name: Crear o reutilizar PR (draft)
        uses: actions/github-script@v7
        env:
          WI:     ${{ env.WI }}
          BRANCH: ${{ steps.br.outputs.branch }}
          BASE:   ${{ steps.base.outputs.base }}
          TITLE:  ${{ env.TITLE }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const head  = `${owner}:${process.env.BRANCH}`;
            const base  = process.env.BASE;
            const wi    = process.env.WI;
            const title = `AB#${wi}: ${process.env.TITLE || '(sin título)'}`.slice(0, 240);

            // ¿Existe PR abierto desde esa rama?
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head });
            if (prs.data.length > 0) {
              core.info(`PR ya existe: #${prs.data[0].number}`);
            } else {
              const pr = await github.rest.pulls.create({
                owner, repo, head: process.env.BRANCH, base, title, draft: true,
                body: `Auto-creado para AB#${wi} (estado ORCH:IN_PROGRESS).`
              });
              core.info(`PR creado: #${pr.data.number}`);
            }

  report:
    name: Reporte (cuando gate bloquea)
    needs: gate
    if: needs.gate.outputs.proceed != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Publicar comentario en PR (si existe)
        uses: actions/github-script@v7
        env:
          WI:       ${{ needs.gate.outputs.wi }}
          REASON:   ${{ needs.gate.outputs.reason }}
          STATE:    ${{ needs.gate.outputs.state }}
          ERR_LIST: ${{ needs.gate.outputs.err_list }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const wi    = process.env.WI;
            const head  = `${owner}:feature/AB${wi}-auto`;

            // Busca PR abierto para esa rama
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head });
            if (prs.data.length === 0) {
              core.info(`No hay PR abierto para AB#${wi}; nada que comentar.`);
              return;
            }
            const pr = prs.data[0];

            const reason = process.env.REASON || 'Gate blocked';
            const state  = process.env.STATE || '(sin estado)';
            const errs   = (process.env.ERR_LIST || '').split('\n').filter(Boolean);

            let body = `⚠️ Orquestación detenida por el *gate*.\n\n- **WI**: AB#${wi}\n- **Estado ORCH**: ${state}\n- **Motivo**: ${reason}\n`;
            if (errs.length) {
              body += `- **Errores**:\n` + errs.map(e => `  - ${e}`).join('\n') + '\n';
            }
            await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body });
            core.info(`Comentario publicado en PR #${pr.number}: ${reason}`);
